# 计算机网络

### 1. 几种网络模型

- OSI七层模型

  **应用层**：应用层为操作系统或网络应用程序提供访问网络服务的接口。例如：文件传输，电子邮件，文件服务，虚拟终端。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。

  **表示层**：它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。没有协议。

  **会话层**：在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为**报文**。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。没有协议。

  **传输层**：在网络层提供的“端到端（IP层）”的服务基础上通过细分服务为多个进程，将IP层提供的“不可靠”的服务转变为“可靠”的服务来实现的。例如，主机到主机，就是端到端（End to End，E2E），它们之间要经过许多跳才能进行数据交互，IP层提供的是“尽力而为”的服务。第4层的数据单元也称作数据包（packet）。但是，当谈论TCP等具体的协议时，TCP的数据单元称为**段 （segment）**而UDP协议的数据单元称为**数据报（datagram）**。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。透明的传输是指在通信过程中传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等。

  **网络层**：选择合适的网间路由和交换结点， 确保数据及时传送。网络层将数据链路层提供的**帧**组成**数据包（packet）**，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。此外还有一些路由协议和地 址解析协议（ARP）。有关路由的一切事情都在这第3层处理。地址解析和路由是网络层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。网络层协议的代表包括：IP、IPX、RIP、OSPF等。

  **数据链路层**：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供**数据帧（Frame）**在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。

  **物理层**：以二进制数据形式在物理媒介上传输数据；ISO2110，IEEE802，IEEE802.2

- TCP/IP五层模型

  物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层

  数据链路层：网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）

  网络层：路由器、三层交换机

  传输层：网关、四层交换机、也有工作在四层的路由器

- Linux TCP/IP四层模型 与七层模型的对应

  应用层：对应应用层+表示层+会话层

  传输层：对应传输层

  网际层：对应网络层

  网络接口层：对应数据链路层+物理层

![img](https://camo.githubusercontent.com/9f3b5e4a6ebfbfe8654376c1b4f87a274bd316648041a22bd12614ab4247c9e5/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e352f3230323130332f6e65742d34392d312e706e67)

- 对比

  网络四层模型是一个实现的应用模型，由七层模型简化合并而来。美国国防部发明的，是让互联网成为了目前这个样子的标准之一。

  开放式系统互联（Open System Interconnet, OSI）模型是一个参考标准，解释协议相互之间应该如何相互作用，而不是具体的实现。开放式系统互联模型中没有清楚地描绘TCP/IP协议。

  TCP/IP协议中的传输层并不能总是保证在传输层可靠地传输数据包，而开放式系统互联模型可以做到。TCP/IP协议还提供一项名为UDP（用户数据报协议）的选择。UDP不能保证可靠的数据包传输。

### 2. 完整的HTTP请求过程

![img](https://img-blog.csdn.net/20180719094756330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 回答一：客户机和服务器建立**TCP连接**（一般HTTP默认的端口号为80）—>Web浏览器向服务器发送**请求命令**—>浏览器发送**请求头消息**—>**服务器应答**，应答的第一部分是版本号和协议状态码—>服务器**发送应答头的信息**—>服务器**发送数据**—>**断开连接**（TCP四次握手)

![img](https://upload-images.jianshu.io/upload_images/2711809-2a200c90f0d08228)

- 回答二：域名解析 —> 与服务器建立连接 —> 发起HTTP请求 —> 服务器响应HTTP请求，浏览器得到html代码 —> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片） —> 浏览器对页面进行渲染呈现给用户

- 回答三：

  1、客户端连接到Web服务器

  一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，[http://www.oakcms.cn](https://link.jianshu.com?t=http://www.oakcms.cn)。

  2、发送HTTP请求

  通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

  3、服务器接受请求并返回HTTP响应

  Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

  4、释放连接[TCP连接](https://www.jianshu.com/p/ef892323e68f)

  若connection 模式为close，则服务器主动关闭[TCP连接](https://www.jianshu.com/p/ef892323e68f)，客户端被动关闭连接，释放[TCP连接](https://www.jianshu.com/p/ef892323e68f);若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

  5、客户端浏览器解析HTML内容

  客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

### 3. TCP三次握手的具体内容

- Client首先发送一个**连接试探**，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入`syn_sent`状态，表示客户端等待服务器的回复
- Server监听到连接请求报文后，如同意建立连接，则**向Client发送确认**。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（若ack=1，其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入`syn_rcvd`，表示服务器已经收到Client的连接请求，等待Client的确认。
- Client收到确认后还需**再次发送确认，同时携带要发送给Server的数据**。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入`Established`状态。

> **注：seq**:"sequence"序列号；**ack**:"acknowledge"确认号；**SYN**:"synchronize"请求同步标志; **ACK**:"acknowledge"确认标志"; **FIN**："Finally"结束标志。

### 4. TCP为什么要三次握手？为什么不能用两次？

通俗来讲三次握手的过程与目的就是：

- 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

三次握手的最主要目的是**保证连接是双工的**，确认双方的接收和发送能力正常。**防止已经失效的连接请求报文段又突然传到服务端**，因而产生错误。

例如，假设是两次握手，若Client发送的一个连接请求在网络节点滞留，以至于延误到连接释放的某个时间才到达Server。Server收到这个请求的报文段后，误以为Client又发出了一次新的请求连接，于是向Client发送确认报文段，同意建立连接。但是由于Client并没有发出新的请求连接，所以Client不会理睬Server的确认也不会向Server发送数据。但Server却认为连接已经建立，一直等待Client发来数据。Server的资源就白白浪费了。又例如，如果服务器的应答分组在传输中丢失，将不知道S建立什么样的序列号，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

### 5. 三次握手过程中可以携带数据吗？

其实第三次握手的时候，是可以携带数据的。但是**第一次、第二次握手不可以携带数据**

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，**第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据不会造成问题。**

### 6. SYN攻击是什么？

SYN攻击就是**Client在短时间内伪造大量不存在的IP地址**，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，**导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪**。SYN 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

常见的防御 SYN 攻击的方法有如下几种：缩短超时（SYN Timeout）时间、增加最大半连接数、过滤网关防护、SYN cookies技术

### 7. 一个TCP连接可以对应几个HTTP请求？

如果使用长连接，一个 TCP 连接是可以对应多个 HTTP 请求的。

### 8. 四次挥手的具体内容

![img](https://camo.githubusercontent.com/26eaa9f2d58674a1ada8f639ba821fb284cf3afcd9a8a6691707b10bb63da7c5/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240312e302f3230323130332f6e65742d36312d312e706e67)

建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也叫做四次握手）。这由TCP的**半关闭**（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。客户端或服务器均可主动发起挥手动作。

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1` 状态。 即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入`FIN_WAIT1`（终止等待1）状态，等待服务端的确认。
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

收到一个FIN只意味着在这一方向上没有数据流动。**客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态**

### 9. HTTP长连接和短连接的区别

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。需要在http头加入”Connection: Keep-Alive”，才能启用 Keep-Alive。

从HTTP/1.1起，默认使用长连接，用以保持连接特性。如果加入”Connection: close ”，才会关闭 Keep-Alive

想要知道是否为长连接，可以观察开发的Web应用的HTTP头部，Connection如果是keep-alive，就是长连接。

但是实际上，HTTP是请求/响应模式的，只要服务端给了响应，本次HTTP请求就结束了，那么久不存在连接这种说法。**长短连接指的是TCP连接**，在长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。比如你请求了一个网页，这个网页里还包含了CSS、JS等等一系列资源，如果是短连接（也就是每次都要重新建立TCP连接）的话，要建立几个甚至几十个TCP连接，浪费了大量资源。如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，可以节省很多消耗。

### 10. HTTP请求方法

客户端发送的 **请求报文** 第一行为请求行，包含了方法字段。

根据 HTTP 标准，HTTP 请求可以使用多种请求方法。最常用的两种是GET和POST，如果是REST ful接口的话一般会用到GET、POST、DELETE、PUT。

HTTP 1.0 定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP 1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序 号 | 方法    | 描述                                                         |
| :---: | ------- | ------------------------------------------------------------ |
|   1   | GET     | 请求指定的页面信息，并返回实体主体。                         |
|   2   | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
|   3   | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
|   4   | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
|   5   | DELETE  | 请求服务器删除指定的页面。                                   |
|   6   | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
|   7   | OPTIONS | 允许客户端查看服务器的性能。                                 |
|   8   | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
|   9   | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

- #### 11. 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？


HTTP/1.1 单个 TCP 连接在同一时刻只能处理一个请求，即，两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。

在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是这个功能在浏览器中默认是关闭的，所以可以认为这是不可行的。在 HTTP/2 中由于 Multiplexing多路传输特性的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。

那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：

- 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。
- 和服务器建立多个 TCP 连接。

### 12. 为什么有的时候刷新页面不需要重新建立 SSL 连接？

如果维持连接的话，是可以复用 TCP 连接的，刷新页面也不需要重新建立 SSL 连接

### 13. 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？

有，Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。

如果使用的是 HTTP/1.1 ，即没有多路传输，当浏览器需要加载有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定不能接受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，即使你的电脑同意 NAT 也不定同意的。

### 14. HTTP请求和响应报文有哪些主要字段？

##### 请求报文

- 请求行：Request Line
- 请求头：Request Headers
- 请求体：Request Body

##### 响应报文

- 状态行：Status Line
- 响应头：Response Headers
- 响应体：Response Body

### 15. 在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？

1、查浏览器缓存，看看有没有已经缓存好的，如果没有

2 、检查本机host文件

3、调用API，Linux下Scoket `gethostbyname` 库函数

4、向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议

6、如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球好像一共有13台根服务器）

7、这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接，

8、经过三次握手成功建立连接后，开始传送数据，如果是http协议的话，就返回就完事了，

9、如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，先四次挥手解除原连接

10、再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换

11、这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。

12、确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页

### 16. HTTPS是什么

> HTTP （超文本传输协议），是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议, 所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

HTTPS（HTTP Secure，超文本传输安全协议）是身披SSL外壳的HTTP。**HTTP+ 加密 + 认证 + 完整性保护  =  HTTPS **HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS (TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分) 在通信接口加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

HTTPS 采用"共享密钥加密"和"公开密钥加密"两者并用的**混合加密**机制。

然而公开密钥加密方法也可能会因为公开密钥被攻击者替换，这需要使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的**公开密钥证书**来证明此公开密钥正确性。首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证。

> 近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。
>
> **共享密钥加密**就是加密和解密用的是同一个密钥，也称为对称密钥加密。但是在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。
>
> **公开密钥加密**使用非对称密钥（私有密钥+公有密钥）。发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。
> 另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。



**HTTPS通信步骤：**

步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的*加密算法*及*密钥长度*等）。

步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。

步骤 3： 之后服务器发送 Certificate 报文。报文中包含*公开密钥证书*。

步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的*SSL握手协商*部分结束。

步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。

步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。

步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。

步骤 8： 服务器同样发送 Change Cipher Spec 报文。

步骤 9： 服务器同样发送 Finished 报文。

步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP请求。

步骤 11： 应用层协议通信，即发送 HTTP 响应。

步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。

### 17. HTTPS和HTTP的区别

1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， 而HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL和 TCP 通信。

2、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

### 18. DNS是什么？

DNS（Domain Name System，域名系统），因特网上作为**域名和IP地址相互映射**的一个**分布式数据库**，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。

比如www.baidu.com对应IP地址：167.23.10.2。

**具体DNS解析工作过程原理**：

- 请求一旦发起，若是chrome浏览器，先在浏览器找之前**有没有缓存过的域名所对应的ip地址**，有的话，直接跳过dns解析，若是没有，就会**找硬盘的hosts文件**，看看有没有，有的话，直接找到hosts文件里面的ip
- 如果本地的hosts文件没有能的到对应的ip地址，浏览器会发出一个**dns请求到本地dns服务器**，本地dns服务器一般都是由网络接入服务器商提供，比如中国电信，中国移动等。
- 查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先**查询它的缓存记录**，如果缓存中有此条记录，就可以直接返回结果，此过程是**递归的方式进行查询**。如果没有，本地DNS服务器还要向**DNS根服务器**进行查询。
- 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是**告诉本地DNS服务器域名的解析服务器的地址**。
- 最后，本地DNS服务器向**域名的解析服务器**发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

![img](https://camo.githubusercontent.com/75b14394ec52c6bbdb7f1a130ed26c7ac43ee401a7b67e22be492c7e7e79462d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e312f3230323130332f2f515125453625383825414125453525394225424532303231303331373130343034352e706e67)





参考资料：

[https://blog.csdn.net/LRH0211/article/details/72724361]()

[https://blog.csdn.net/ywlmsm1224811/article/details/96436768]()

[https://github.com/forthespada/InterviewGuide/blob/main/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#sob-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C](https://github.com/forthespada/InterviewGuide/blob/main/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#sob-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C)

[https://www.jianshu.com/p/2f6705a16a20](https://www.jianshu.com/p/2f6705a16a20)

[https://www.jianshu.com/p/80e25cb1d81a](https://www.jianshu.com/p/80e25cb1d81a)

[https://blog.csdn.net/xiaoming100001/article/details/81109617](https://blog.csdn.net/xiaoming100001/article/details/81109617)

